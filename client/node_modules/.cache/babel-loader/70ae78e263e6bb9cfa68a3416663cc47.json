{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range');else if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);\n  return buf;\n};\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80;\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff;\n    num = Math.floor(num / 0x100);\n  }\n};\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff;\n    num = Math.floor(num / 0x100);\n    if (flipped) buf[i - 1] = onesComp(byte);else if (byte === 0) buf[i - 1] = 0;else {\n      flipped = true;\n      buf[i - 1] = twosComp(byte);\n    }\n  }\n};\n\nconst parse = buf => {\n  const pre = buf[0];\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length)) : pre === 0xff ? twos(buf) : null;\n  if (value === null) throw Error('invalid base256 encoding');\n  if (!Number.isSafeInteger(value)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range');\n  return value;\n};\n\nconst twos = buf => {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n    if (flipped) f = onesComp(byte);else if (byte === 0) f = byte;else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n    if (f !== 0) sum -= f * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nconst pos = buf => {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nconst onesComp = byte => (0xff ^ byte) & 0xff;\n\nconst twosComp = byte => (0xff ^ byte) + 1 & 0xff;\n\nmodule.exports = {\n  encode,\n  parse\n};","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/tar/lib/large-numbers.js"],"names":["encode","num","buf","Number","isSafeInteger","Error","encodeNegative","encodePositive","i","length","Math","floor","flipped","byte","onesComp","twosComp","parse","pre","value","pos","slice","twos","len","sum","f","pow","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i - 1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i - 1] = 0\n    else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null)\n    throw Error('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n"]},"metadata":{},"sourceType":"script"}