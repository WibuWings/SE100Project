{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = build;\nexports.usage = 'Attempts to compile the module by dispatching to node-gyp or nw-gyp';\n\nconst napi = require('./util/napi.js');\n\nconst compile = require('./util/compile.js');\n\nconst handle_gyp_opts = require('./util/handle_gyp_opts.js');\n\nconst configure = require('./configure.js');\n\nfunction do_build(gyp, argv, callback) {\n  handle_gyp_opts(gyp, argv, (err, result) => {\n    let final_args = ['build'].concat(result.gyp).concat(result.pre);\n\n    if (result.unparsed.length > 0) {\n      final_args = final_args.concat(['--']).concat(result.unparsed);\n    }\n\n    if (!err && result.opts.napi_build_version) {\n      napi.swap_build_dir_in(result.opts.napi_build_version);\n    }\n\n    compile.run_gyp(final_args, result.opts, err2 => {\n      if (result.opts.napi_build_version) {\n        napi.swap_build_dir_out(result.opts.napi_build_version);\n      }\n\n      return callback(err2);\n    });\n  });\n}\n\nfunction build(gyp, argv, callback) {\n  // Form up commands to pass to node-gyp:\n  // We map `node-pre-gyp build` to `node-gyp configure build` so that we do not\n  // trigger a clean and therefore do not pay the penalty of a full recompile\n  if (argv.length && argv.indexOf('rebuild') > -1) {\n    argv.shift(); // remove `rebuild`\n    // here we map `node-pre-gyp rebuild` to `node-gyp rebuild` which internally means\n    // \"clean + configure + build\" and triggers a full recompile\n\n    compile.run_gyp(['clean'], {}, err3 => {\n      if (err3) return callback(err3);\n      configure(gyp, argv, err4 => {\n        if (err4) return callback(err4);\n        return do_build(gyp, argv, callback);\n      });\n    });\n  } else {\n    return do_build(gyp, argv, callback);\n  }\n}","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/@mapbox/node-pre-gyp/lib/build.js"],"names":["module","exports","build","usage","napi","require","compile","handle_gyp_opts","configure","do_build","gyp","argv","callback","err","result","final_args","concat","pre","unparsed","length","opts","napi_build_version","swap_build_dir_in","run_gyp","err2","swap_build_dir_out","indexOf","shift","err3","err4"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGC,KAA3B;AAEAD,OAAO,CAACE,KAAR,GAAgB,qEAAhB;;AAEA,MAAMC,IAAI,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,2BAAD,CAA/B;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,gBAAD,CAAzB;;AAEA,SAASI,QAAT,CAAkBC,GAAlB,EAAuBC,IAAvB,EAA6BC,QAA7B,EAAuC;AACrCL,EAAAA,eAAe,CAACG,GAAD,EAAMC,IAAN,EAAY,CAACE,GAAD,EAAMC,MAAN,KAAiB;AAC1C,QAAIC,UAAU,GAAG,CAAC,OAAD,EAAUC,MAAV,CAAiBF,MAAM,CAACJ,GAAxB,EAA6BM,MAA7B,CAAoCF,MAAM,CAACG,GAA3C,CAAjB;;AACA,QAAIH,MAAM,CAACI,QAAP,CAAgBC,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BJ,MAAAA,UAAU,GAAGA,UAAU,CACrBC,MADW,CACJ,CAAC,IAAD,CADI,EAEXA,MAFW,CAEJF,MAAM,CAACI,QAFH,CAAb;AAGD;;AACD,QAAI,CAACL,GAAD,IAAQC,MAAM,CAACM,IAAP,CAAYC,kBAAxB,EAA4C;AAC1CjB,MAAAA,IAAI,CAACkB,iBAAL,CAAuBR,MAAM,CAACM,IAAP,CAAYC,kBAAnC;AACD;;AACDf,IAAAA,OAAO,CAACiB,OAAR,CAAgBR,UAAhB,EAA4BD,MAAM,CAACM,IAAnC,EAA0CI,IAAD,IAAU;AACjD,UAAIV,MAAM,CAACM,IAAP,CAAYC,kBAAhB,EAAoC;AAClCjB,QAAAA,IAAI,CAACqB,kBAAL,CAAwBX,MAAM,CAACM,IAAP,CAAYC,kBAApC;AACD;;AACD,aAAOT,QAAQ,CAACY,IAAD,CAAf;AACD,KALD;AAMD,GAhBc,CAAf;AAiBD;;AAED,SAAStB,KAAT,CAAeQ,GAAf,EAAoBC,IAApB,EAA0BC,QAA1B,EAAoC;AAElC;AACA;AACA;AACA,MAAID,IAAI,CAACQ,MAAL,IAAgBR,IAAI,CAACe,OAAL,CAAa,SAAb,IAA0B,CAAC,CAA/C,EAAmD;AACjDf,IAAAA,IAAI,CAACgB,KAAL,GADiD,CACnC;AACd;AACA;;AACArB,IAAAA,OAAO,CAACiB,OAAR,CAAgB,CAAC,OAAD,CAAhB,EAA2B,EAA3B,EAAgCK,IAAD,IAAU;AACvC,UAAIA,IAAJ,EAAU,OAAOhB,QAAQ,CAACgB,IAAD,CAAf;AACVpB,MAAAA,SAAS,CAACE,GAAD,EAAMC,IAAN,EAAakB,IAAD,IAAU;AAC7B,YAAIA,IAAJ,EAAU,OAAOjB,QAAQ,CAACiB,IAAD,CAAf;AACV,eAAOpB,QAAQ,CAACC,GAAD,EAAMC,IAAN,EAAYC,QAAZ,CAAf;AACD,OAHQ,CAAT;AAID,KAND;AAOD,GAXD,MAWO;AACL,WAAOH,QAAQ,CAACC,GAAD,EAAMC,IAAN,EAAYC,QAAZ,CAAf;AACD;AACF","sourcesContent":["'use strict';\n\nmodule.exports = exports = build;\n\nexports.usage = 'Attempts to compile the module by dispatching to node-gyp or nw-gyp';\n\nconst napi = require('./util/napi.js');\nconst compile = require('./util/compile.js');\nconst handle_gyp_opts = require('./util/handle_gyp_opts.js');\nconst configure = require('./configure.js');\n\nfunction do_build(gyp, argv, callback) {\n  handle_gyp_opts(gyp, argv, (err, result) => {\n    let final_args = ['build'].concat(result.gyp).concat(result.pre);\n    if (result.unparsed.length > 0) {\n      final_args = final_args.\n        concat(['--']).\n        concat(result.unparsed);\n    }\n    if (!err && result.opts.napi_build_version) {\n      napi.swap_build_dir_in(result.opts.napi_build_version);\n    }\n    compile.run_gyp(final_args, result.opts, (err2) => {\n      if (result.opts.napi_build_version) {\n        napi.swap_build_dir_out(result.opts.napi_build_version);\n      }\n      return callback(err2);\n    });\n  });\n}\n\nfunction build(gyp, argv, callback) {\n\n  // Form up commands to pass to node-gyp:\n  // We map `node-pre-gyp build` to `node-gyp configure build` so that we do not\n  // trigger a clean and therefore do not pay the penalty of a full recompile\n  if (argv.length && (argv.indexOf('rebuild') > -1)) {\n    argv.shift(); // remove `rebuild`\n    // here we map `node-pre-gyp rebuild` to `node-gyp rebuild` which internally means\n    // \"clean + configure + build\" and triggers a full recompile\n    compile.run_gyp(['clean'], {}, (err3) => {\n      if (err3) return callback(err3);\n      configure(gyp, argv, (err4) => {\n        if (err4) return callback(err4);\n        return do_build(gyp, argv, callback);\n      });\n    });\n  } else {\n    return do_build(gyp, argv, callback);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}