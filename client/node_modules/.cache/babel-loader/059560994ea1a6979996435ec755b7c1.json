{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst EE = require('events').EventEmitter;\n\nconst fs = require('fs');\n\nlet writev = fs.writev;\n/* istanbul ignore next */\n\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs');\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec);\n\n    const req = new FSReqWrap();\n    req.oncomplete = done;\n    binding.writeBuffers(fd, iovec, pos, req);\n  };\n}\n\nconst _autoClose = Symbol('_autoClose');\n\nconst _close = Symbol('_close');\n\nconst _ended = Symbol('_ended');\n\nconst _fd = Symbol('_fd');\n\nconst _finished = Symbol('_finished');\n\nconst _flags = Symbol('_flags');\n\nconst _flush = Symbol('_flush');\n\nconst _handleChunk = Symbol('_handleChunk');\n\nconst _makeBuf = Symbol('_makeBuf');\n\nconst _mode = Symbol('_mode');\n\nconst _needDrain = Symbol('_needDrain');\n\nconst _onerror = Symbol('_onerror');\n\nconst _onopen = Symbol('_onopen');\n\nconst _onread = Symbol('_onread');\n\nconst _onwrite = Symbol('_onwrite');\n\nconst _open = Symbol('_open');\n\nconst _path = Symbol('_path');\n\nconst _pos = Symbol('_pos');\n\nconst _queue = Symbol('_queue');\n\nconst _read = Symbol('_read');\n\nconst _readSize = Symbol('_readSize');\n\nconst _reading = Symbol('_reading');\n\nconst _remain = Symbol('_remain');\n\nconst _size = Symbol('_size');\n\nconst _write = Symbol('_write');\n\nconst _writing = Symbol('_writing');\n\nconst _defaultFlag = Symbol('_defaultFlag');\n\nconst _errored = Symbol('_errored');\n\nclass ReadStream extends MiniPass {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.readable = true;\n    this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    this[_errored] = false;\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_path] = path;\n    this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    this[_reading] = false;\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    this[_remain] = this[_size];\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof this[_fd] === 'number') this[_read]();else this[_open]();\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  write() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  end() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  [_open]() {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_read]();\n    }\n  }\n\n  [_makeBuf]() {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n  }\n\n  [_read]() {\n    if (!this[_reading]) {\n      this[_reading] = true;\n\n      const buf = this[_makeBuf]();\n      /* istanbul ignore if */\n\n\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf));\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) => this[_onread](er, br, buf));\n    }\n  }\n\n  [_onread](er, br, buf) {\n    this[_reading] = false;\n    if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd];\n      this[_fd] = null;\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n    }\n  }\n\n  [_onerror](er) {\n    this[_reading] = true;\n\n    this[_close]();\n\n    this.emit('error', er);\n  }\n\n  [_handleChunk](br, buf) {\n    let ret = false; // no effect if infinite\n\n    this[_remain] -= br;\n    if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false;\n\n      this[_close]();\n\n      super.end();\n    }\n\n    return ret;\n  }\n\n  emit(ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break;\n\n      case 'drain':\n        if (typeof this[_fd] === 'number') this[_read]();\n        break;\n\n      case 'error':\n        if (this[_errored]) return;\n        this[_errored] = true;\n        return super.emit(ev, data);\n\n      default:\n        return super.emit(ev, data);\n    }\n  }\n\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open]() {\n    let threw = true;\n\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'));\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_read]() {\n    let threw = true;\n\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true;\n\n        do {\n          const buf = this[_makeBuf]();\n          /* istanbul ignore next */\n\n\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n          if (!this[_handleChunk](br, buf)) break;\n        } while (true);\n\n        this[_reading] = false;\n      }\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd];\n      this[_fd] = null;\n      fs.closeSync(fd);\n      this.emit('close');\n    }\n  }\n\n}\n\nclass WriteStream extends EE {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.readable = false;\n    this.writable = true;\n    this[_errored] = false;\n    this[_writing] = false;\n    this[_ended] = false;\n    this[_needDrain] = false;\n    this[_queue] = [];\n    this[_path] = path;\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle\n\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w';\n    this[_defaultFlag] = opt.flags === undefined;\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;\n    if (this[_fd] === null) this[_open]();\n  }\n\n  emit(ev, data) {\n    if (ev === 'error') {\n      if (this[_errored]) return;\n      this[_errored] = true;\n    }\n\n    return super.emit(ev, data);\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  [_onerror](er) {\n    this[_close]();\n\n    this[_writing] = true;\n    this.emit('error', er);\n  }\n\n  [_open]() {\n    fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n      this[_flags] = 'w';\n\n      this[_open]();\n    } else if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_flush]();\n    }\n  }\n\n  end(buf, enc) {\n    if (buf) this.write(buf, enc);\n    this[_ended] = true; // synthetic after-write logic, where drain/finish live\n\n    if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n    return this;\n  }\n\n  write(buf, enc) {\n    if (typeof buf === 'string') buf = Buffer.from(buf, enc);\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'));\n      return false;\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf);\n\n      this[_needDrain] = true;\n      return false;\n    }\n\n    this[_writing] = true;\n\n    this[_write](buf);\n\n    return true;\n  }\n\n  [_write](buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n  }\n\n  [_onwrite](er, bw) {\n    if (er) this[_onerror](er);else {\n      if (this[_pos] !== null) this[_pos] += bw;\n      if (this[_queue].length) this[_flush]();else {\n        this[_writing] = false;\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true;\n\n          this[_close]();\n\n          this.emit('finish');\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false;\n          this.emit('drain');\n        }\n      }\n    }\n  }\n\n  [_flush]() {\n    if (this[_queue].length === 0) {\n      if (this[_ended]) this[_onwrite](null, 0);\n    } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n      const iovec = this[_queue];\n      this[_queue] = [];\n      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd];\n      this[_fd] = null;\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n    }\n  }\n\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open]() {\n    let fd; // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w';\n          return this[_open]();\n        } else throw er;\n      }\n    } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n\n    this[_onopen](null, fd);\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd];\n      this[_fd] = null;\n      fs.closeSync(fd);\n      this.emit('close');\n    }\n  }\n\n  [_write](buf) {\n    // throw the original, but try to close if it fails\n    let threw = true;\n\n    try {\n      this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n\n      threw = false;\n    } finally {\n      if (threw) try {\n        this[_close]();\n      } catch (_) {}\n    }\n  }\n\n}\n\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/fs-minipass/index.js"],"names":["MiniPass","require","EE","EventEmitter","fs","writev","binding","process","FSReqWrap","FSReqCallback","fd","iovec","pos","cb","done","er","bw","req","oncomplete","writeBuffers","_autoClose","Symbol","_close","_ended","_fd","_finished","_flags","_flush","_handleChunk","_makeBuf","_mode","_needDrain","_onerror","_onopen","_onread","_onwrite","_open","_path","_pos","_queue","_read","_readSize","_reading","_remain","_size","_write","_writing","_defaultFlag","_errored","ReadStream","constructor","path","opt","readable","writable","TypeError","readSize","size","Infinity","autoClose","write","end","open","emit","Buffer","allocUnsafe","Math","min","buf","length","nextTick","read","br","close","ret","slice","ev","data","ReadStreamSync","threw","openSync","readSync","closeSync","WriteStream","mode","undefined","start","defaultFlag","flags","code","enc","from","Error","push","pop","WriteStreamSync","writeSync","_","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n"]},"metadata":{},"sourceType":"script"}