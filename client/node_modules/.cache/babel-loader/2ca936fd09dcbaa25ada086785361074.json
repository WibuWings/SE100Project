{"ast":null,"code":"'use strict';\n\nvar Promise = global.Promise; /// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\n\nmodule.exports.promise = function (fn, context, args) {\n  if (!Array.isArray(args)) {\n    args = Array.prototype.slice.call(args);\n  }\n\n  if (typeof fn !== 'function') {\n    return Promise.reject(new Error('fn must be a function'));\n  }\n\n  return new Promise(function (resolve, reject) {\n    args.push(function (err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n    fn.apply(context, args);\n  });\n}; /// @param {err} the error to be thrown\n\n\nmodule.exports.reject = function (err) {\n  return Promise.reject(err);\n}; /// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\n\n\nmodule.exports.use = function (promise) {\n  Promise = promise;\n};","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/bcrypt/promises.js"],"names":["Promise","global","module","exports","promise","fn","context","args","Array","isArray","prototype","slice","call","reject","Error","resolve","push","err","data","apply","use"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,MAAM,CAACD,OAArB,C,CAEA;AACA;AACA;AACA;AACA;;AACAE,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyB,UAAUC,EAAV,EAAcC,OAAd,EAAuBC,IAAvB,EAA6B;AAElD,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACtBA,IAAAA,IAAI,GAAGC,KAAK,CAACE,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BL,IAA3B,CAAP;AACH;;AAED,MAAI,OAAOF,EAAP,KAAc,UAAlB,EAA8B;AAC1B,WAAOL,OAAO,CAACa,MAAR,CAAe,IAAIC,KAAJ,CAAU,uBAAV,CAAf,CAAP;AACH;;AAED,SAAO,IAAId,OAAJ,CAAY,UAASe,OAAT,EAAkBF,MAAlB,EAA0B;AACzCN,IAAAA,IAAI,CAACS,IAAL,CAAU,UAASC,GAAT,EAAcC,IAAd,EAAoB;AAC1B,UAAID,GAAJ,EAAS;AACLJ,QAAAA,MAAM,CAACI,GAAD,CAAN;AACH,OAFD,MAEO;AACHF,QAAAA,OAAO,CAACG,IAAD,CAAP;AACH;AACJ,KAND;AAQAb,IAAAA,EAAE,CAACc,KAAH,CAASb,OAAT,EAAkBC,IAAlB;AACH,GAVM,CAAP;AAWH,CArBD,C,CAuBA;;;AACAL,MAAM,CAACC,OAAP,CAAeU,MAAf,GAAwB,UAAUI,GAAV,EAAe;AACnC,SAAOjB,OAAO,CAACa,MAAR,CAAeI,GAAf,CAAP;AACH,CAFD,C,CAIA;AACA;;;AACAf,MAAM,CAACC,OAAP,CAAeiB,GAAf,GAAqB,UAAShB,OAAT,EAAkB;AACrCJ,EAAAA,OAAO,GAAGI,OAAV;AACD,CAFD","sourcesContent":["'use strict';\n\nvar Promise = global.Promise;\n\n/// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\nmodule.exports.promise = function (fn, context, args) {\n\n    if (!Array.isArray(args)) {\n        args = Array.prototype.slice.call(args);\n    }\n\n    if (typeof fn !== 'function') {\n        return Promise.reject(new Error('fn must be a function'));\n    }\n\n    return new Promise(function(resolve, reject) {\n        args.push(function(err, data) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n\n        fn.apply(context, args);\n    });\n};\n\n/// @param {err} the error to be thrown\nmodule.exports.reject = function (err) {\n    return Promise.reject(err);\n};\n\n/// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\nmodule.exports.use = function(promise) {\n  Promise = promise;\n};\n"]},"metadata":{},"sourceType":"script"}