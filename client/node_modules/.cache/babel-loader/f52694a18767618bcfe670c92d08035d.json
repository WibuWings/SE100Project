{"ast":null,"code":"'use strict'; // tar -r\n\nconst hlo = require('./high-level-opt.js');\n\nconst Pack = require('./pack.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst t = require('./list.js');\n\nconst path = require('path'); // starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\n\nconst Header = require('./header.js');\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n  if (!opt.file) throw new TypeError('file is required');\n  if (opt.gzip) throw new TypeError('cannot append to compressed archives');\n  if (!files || !Array.isArray(files) || !files.length) throw new TypeError('no files or directories specified');\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') fd = fs.openSync(opt.file, 'w+');else throw er;\n    }\n\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) throw new Error('cannot append to compressed archives');\n        if (!bytes) break POSITION;\n      }\n\n      const h = new Header(headBuf);\n      if (!h.cksumValid) break;\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) break; // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n\n      position += entryBlockSize;\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n    }\n\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) fs.close(fd, _ => cb_(er));else cb_(null, pos);\n    };\n\n    let position = 0;\n    if (size === 0) return cb(null, 0);\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n\n    const onread = (er, bytes) => {\n      if (er) return cb(er);\n      bufPos += bytes;\n\n      if (bufPos < 512 && bytes) {\n        return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) return cb(new Error('cannot append to compressed archives')); // truncated header\n\n      if (bufPos < 512) return cb(null, position);\n      const h = new Header(headBuf);\n      if (!h.cksumValid) return cb(null, position);\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) return cb(null, position);\n      position += entryBlockSize + 512;\n      if (position >= size) return cb(null, position);\n      if (opt.mtimeCache) opt.mtimeCache.set(h.path, h.mtime);\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n\n      if (er) return reject(er);\n      fs.fstat(fd, (er, st) => {\n        if (er) return fs.close(fd, () => reject(er));\n        getPos(fd, st.size, (er, position) => {\n          if (er) return reject(er);\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      });\n    } else p.add(file);\n  });\n  p.end();\n};\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files));\n    } else p.add(file);\n  }\n\n  p.end();\n};","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/tar/lib/replace.js"],"names":["hlo","require","Pack","fs","fsm","t","path","Header","module","exports","opt_","files","cb","opt","file","TypeError","gzip","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","Buffer","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","substr","noResume","onentry","entry","add","end","shift"],"mappings":"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","sourcesContent":["'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return fs.close(fd, () => reject(er))\n\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else\n      p.add(file)\n  }\n  p.end()\n}\n"]},"metadata":{},"sourceType":"script"}