{"ast":null,"code":"module.exports = exports = abbrev.abbrev = abbrev;\nabbrev.monkeyPatch = monkeyPatch;\n\nfunction monkeyPatch() {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function () {\n      return abbrev(this);\n    },\n    enumerable: false,\n    configurable: true,\n    writable: true\n  });\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function () {\n      return abbrev(Object.keys(this));\n    },\n    enumerable: false,\n    configurable: true,\n    writable: true\n  });\n}\n\nfunction abbrev(list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0);\n  }\n\n  for (var i = 0, l = list.length, args = []; i < l; i++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i]);\n  } // sort them lexicographically, so that they're next to their nearest kin\n\n\n  args = args.sort(lexSort); // walk through each, seeing how much it has in common with the next and previous\n\n  var abbrevs = {},\n      prev = \"\";\n\n  for (var i = 0, l = args.length; i < l; i++) {\n    var current = args[i],\n        next = args[i + 1] || \"\",\n        nextMatches = true,\n        prevMatches = true;\n    if (current === next) continue;\n\n    for (var j = 0, cl = current.length; j < cl; j++) {\n      var curChar = current.charAt(j);\n      nextMatches = nextMatches && curChar === next.charAt(j);\n      prevMatches = prevMatches && curChar === prev.charAt(j);\n\n      if (!nextMatches && !prevMatches) {\n        j++;\n        break;\n      }\n    }\n\n    prev = current;\n\n    if (j === cl) {\n      abbrevs[current] = current;\n      continue;\n    }\n\n    for (var a = current.substr(0, j); j <= cl; j++) {\n      abbrevs[a] = current;\n      a += current.charAt(j);\n    }\n  }\n\n  return abbrevs;\n}\n\nfunction lexSort(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/abbrev/abbrev.js"],"names":["module","exports","abbrev","monkeyPatch","Object","defineProperty","Array","prototype","value","enumerable","configurable","writable","keys","list","arguments","length","isArray","slice","call","i","l","args","String","sort","lexSort","abbrevs","prev","current","next","nextMatches","prevMatches","j","cl","curChar","charAt","a","substr","b"],"mappings":"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","sourcesContent":["module.exports = exports = abbrev.abbrev = abbrev\n\nabbrev.monkeyPatch = monkeyPatch\n\nfunction monkeyPatch () {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function () { return abbrev(this) },\n    enumerable: false, configurable: true, writable: true\n  })\n\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function () { return abbrev(Object.keys(this)) },\n    enumerable: false, configurable: true, writable: true\n  })\n}\n\nfunction abbrev (list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0)\n  }\n  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i])\n  }\n\n  // sort them lexicographically, so that they're next to their nearest kin\n  args = args.sort(lexSort)\n\n  // walk through each, seeing how much it has in common with the next and previous\n  var abbrevs = {}\n    , prev = \"\"\n  for (var i = 0, l = args.length ; i < l ; i ++) {\n    var current = args[i]\n      , next = args[i + 1] || \"\"\n      , nextMatches = true\n      , prevMatches = true\n    if (current === next) continue\n    for (var j = 0, cl = current.length ; j < cl ; j ++) {\n      var curChar = current.charAt(j)\n      nextMatches = nextMatches && curChar === next.charAt(j)\n      prevMatches = prevMatches && curChar === prev.charAt(j)\n      if (!nextMatches && !prevMatches) {\n        j ++\n        break\n      }\n    }\n    prev = current\n    if (j === cl) {\n      abbrevs[current] = current\n      continue\n    }\n    for (var a = current.substr(0, j) ; j <= cl ; j ++) {\n      abbrevs[a] = current\n      a += current.charAt(j)\n    }\n  }\n  return abbrevs\n}\n\nfunction lexSort (a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n"]},"metadata":{},"sourceType":"script"}