{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst Buffer = require('buffer').Buffer;\n\nconst realZlib = require('zlib');\n\nconst constants = exports.constants = require('./constants.js');\n\nconst Minipass = require('minipass');\n\nconst OriginalBufferConcat = Buffer.concat;\n\nconst _superWrite = Symbol('_superWrite');\n\nclass ZlibError extends Error {\n  constructor(err) {\n    super('zlib: ' + err.message);\n    this.code = err.code;\n    this.errno = err.errno;\n    /* istanbul ignore if */\n\n    if (!this.code) this.code = 'ZLIB_ERROR';\n    this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  get name() {\n    return 'ZlibError';\n  }\n\n} // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nconst _opts = Symbol('opts');\n\nconst _flushFlag = Symbol('flushFlag');\n\nconst _finishFlushFlag = Symbol('finishFlushFlag');\n\nconst _fullFlushFlag = Symbol('fullFlushFlag');\n\nconst _handle = Symbol('handle');\n\nconst _onError = Symbol('onError');\n\nconst _sawError = Symbol('sawError');\n\nconst _level = Symbol('level');\n\nconst _strategy = Symbol('strategy');\n\nconst _ended = Symbol('ended');\n\nconst _defaultFullFlush = Symbol('_defaultFullFlush');\n\nclass ZlibBase extends Minipass {\n  constructor(opts, mode) {\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    super(opts);\n    this[_sawError] = false;\n    this[_ended] = false;\n    this[_opts] = opts;\n    this[_flushFlag] = opts.flush;\n    this[_finishFlushFlag] = opts.finishFlush; // this will throw if any options are invalid for the class selected\n\n    try {\n      this[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n\n    this[_onError] = err => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError]) return;\n      this[_sawError] = true; // there is no way to cleanly recover.\n      // continuing only obscures problems.\n\n      this.close();\n      this.emit('error', err);\n    };\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)));\n\n    this.once('end', () => this.close);\n  }\n\n  close() {\n    if (this[_handle]) {\n      this[_handle].close();\n\n      this[_handle] = null;\n      this.emit('close');\n    }\n  }\n\n  reset() {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed');\n      return this[_handle].reset();\n    }\n  }\n\n  flush(flushFlag) {\n    if (this.ended) return;\n    if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n    this.write(Object.assign(Buffer.alloc(0), {\n      [_flushFlag]: flushFlag\n    }));\n  }\n\n  end(chunk, encoding, cb) {\n    if (chunk) this.write(chunk, encoding);\n    this.flush(this[_finishFlushFlag]);\n    this[_ended] = true;\n    return super.end(null, null, cb);\n  }\n\n  get ended() {\n    return this[_ended];\n  }\n\n  write(chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n    if (this[_sawError]) return;\n    assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n\n    const nativeHandle = this[_handle]._handle;\n    const originalNativeClose = nativeHandle.close;\n\n    nativeHandle.close = () => {};\n\n    const originalClose = this[_handle].close;\n\n    this[_handle].close = () => {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n\n\n    Buffer.concat = args => args;\n\n    let result;\n\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n      result = this[_handle]._processChunk(chunk, flushFlag); // if we don't throw, reset it back how it was\n\n      Buffer.concat = OriginalBufferConcat;\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat;\n\n      this[_onError](new ZlibError(err));\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle;\n        nativeHandle.close = originalNativeClose;\n        this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n\n        this[_handle].removeAllListeners('error'); // make sure OUR error listener is still attached tho\n\n      }\n    }\n\n    if (this[_handle]) this[_handle].on('error', er => this[_onError](new ZlibError(er)));\n    let writeReturn;\n\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]));\n\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i]);\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result));\n      }\n    }\n\n    if (cb) cb();\n    return writeReturn;\n  }\n\n  [_superWrite](data) {\n    return super.write(data);\n  }\n\n}\n\nclass Zlib extends ZlibBase {\n  constructor(opts, mode) {\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    super(opts, mode);\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    this[_level] = opts.level;\n    this[_strategy] = opts.strategy;\n  }\n\n  params(level, strategy) {\n    if (this[_sawError]) return;\n    if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n    /* istanbul ignore if */\n\n    if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH);\n      assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n\n      const origFlush = this[_handle].flush;\n\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag);\n        cb();\n      };\n\n      try {\n        this[_handle].params(level, strategy);\n      } finally {\n        this[_handle].flush = origFlush;\n      }\n      /* istanbul ignore else */\n\n\n      if (this[_handle]) {\n        this[_level] = level;\n        this[_strategy] = strategy;\n      }\n    }\n  }\n\n} // minimal 2-byte header\n\n\nclass Deflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Deflate');\n  }\n\n}\n\nclass Inflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Inflate');\n  }\n\n} // gzip - bigger header, same deflate compression\n\n\nconst _portable = Symbol('_portable');\n\nclass Gzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gzip');\n    this[_portable] = opts && !!opts.portable;\n  }\n\n  [_superWrite](data) {\n    if (!this[_portable]) return super[_superWrite](data); // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n\n    this[_portable] = false;\n    data[9] = 255;\n    return super[_superWrite](data);\n  }\n\n}\n\nclass Gunzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gunzip');\n  }\n\n} // raw - no header\n\n\nclass DeflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'DeflateRaw');\n  }\n\n}\n\nclass InflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'InflateRaw');\n  }\n\n} // auto-detect header.\n\n\nclass Unzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Unzip');\n  }\n\n}\n\nclass Brotli extends ZlibBase {\n  constructor(opts, mode) {\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    super(opts, mode);\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n  }\n\n}\n\nclass BrotliCompress extends Brotli {\n  constructor(opts) {\n    super(opts, 'BrotliCompress');\n  }\n\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor(opts) {\n    super(opts, 'BrotliDecompress');\n  }\n\n}\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\n\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor() {\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n\n  };\n}","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/minizlib/index.js"],"names":["assert","require","Buffer","realZlib","constants","exports","Minipass","OriginalBufferConcat","concat","_superWrite","Symbol","ZlibError","Error","constructor","err","message","code","errno","captureStackTrace","name","_opts","_flushFlag","_finishFlushFlag","_fullFlushFlag","_handle","_onError","_sawError","_level","_strategy","_ended","_defaultFullFlush","ZlibBase","opts","mode","TypeError","flush","finishFlush","er","close","emit","on","once","reset","flushFlag","ended","write","Object","assign","alloc","end","chunk","encoding","cb","from","nativeHandle","originalNativeClose","originalClose","args","result","_processChunk","removeAllListeners","writeReturn","Array","isArray","length","i","data","Zlib","Z_NO_FLUSH","Z_FINISH","Z_FULL_FLUSH","level","strategy","params","Z_SYNC_FLUSH","origFlush","Deflate","Inflate","_portable","Gzip","portable","Gunzip","DeflateRaw","InflateRaw","Unzip","Brotli","BROTLI_OPERATION_PROCESS","BROTLI_OPERATION_FINISH","BROTLI_OPERATION_FLUSH","BrotliCompress","BrotliDecompress"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}