{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst log = require('npmlog');\n\nconst existsAsync = fs.exists || path.exists;\n\nconst versioning = require('./util/versioning.js');\n\nconst napi = require('./util/napi.js');\n\nconst makeDir = require('make-dir'); // for fetching binaries\n\n\nconst fetch = require('node-fetch');\n\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {// do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri); // Try getting version info from the currently running npm.\n\n  const envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  let agent;\n\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, {\n    agent\n  }).then(res => {\n    if (!res.ok) {\n      throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n    }\n\n    const dataStream = res.body;\n    return new Promise((resolve, reject) => {\n      let extractions = 0;\n\n      const countExtractions = entry => {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', e => {\n        reject(e);\n      });\n      dataStream.on('end', () => {\n        resolve(`extracted file count: ${extractions}`);\n      });\n      dataStream.on('error', e => {\n        reject(e);\n      });\n    });\n  }).then(text => {\n    log.info(text);\n    callback();\n  }).catch(e => {\n    log.error(`install ${e.message}`);\n    callback(e);\n  });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from); // extract helpers\n\n  let extractCount = 0;\n\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n\n  function afterExtract(err) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n} //\n// install\n//\n\n\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    let opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, found => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(err => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/@mapbox/node-pre-gyp/lib/install.js"],"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","makeDir","fetch","tar","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","place_binary","uri","targetDir","opts","callback","http","envVersionInfo","process","env","npm_config_user_agent","sanitized","replace","requestOpts","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","agent","ProxyAgent","then","res","ok","Error","status","statusText","dataStream","body","Promise","resolve","reject","extractions","countExtractions","entry","info","pipe","extract","on","text","catch","error","message","to","onentry","cwd","strip","extract_from_local","from","existsSync","extractCount","afterExtract","err","createReadStream","do_build","gyp","argv","args","concat","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","statusCode","undefined","runtime","target","versions","node","node_abi","libc","warn","hosted_tarball","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","match","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","fileName","startsWith","slice","after_place"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst makeDir = require('make-dir');\n// for fetching binaries\nconst fetch = require('node-fetch');\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  const envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n  let agent;\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, { agent })\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n      }\n      const dataStream = res.body;\n\n      return new Promise((resolve, reject) => {\n        let extractions = 0;\n        const countExtractions = (entry) => {\n          extractions += 1;\n          log.info('install', 'unpacking %s', entry.path);\n        };\n\n        dataStream.pipe(extract(targetDir, countExtractions))\n          .on('error', (e) => {\n            reject(e);\n          });\n        dataStream.on('end', () => {\n          resolve(`extracted file count: ${extractions}`);\n        });\n        dataStream.on('error', (e) => {\n          reject(e);\n        });\n      });\n    })\n    .then((text) => {\n      log.info(text);\n      callback();\n    })\n    .catch((e) => {\n      log.error(`install ${e.message}`);\n      callback(e);\n    });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  let extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))\n    .on('close', afterExtract)\n    .on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({ name: 'build', args: args });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    let opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, (found) => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch((err) => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}