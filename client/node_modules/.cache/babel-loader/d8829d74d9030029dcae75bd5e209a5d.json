{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nconst normPath = require('./normalize-windows-path.js');\n\nclass SymlinkError extends Error {\n  constructor(symlink, path) {\n    super('Cannot extract through symbolic link');\n    this.path = path;\n    this.symlink = symlink;\n  }\n\n  get name() {\n    return 'SylinkError';\n  }\n\n}\n\nclass CwdError extends Error {\n  constructor(path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'');\n    this.path = path;\n    this.code = code;\n  }\n\n  get name() {\n    return 'CwdError';\n  }\n\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key));\n\nconst cSet = (cache, key, val) => cache.set(normPath(key), val);\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    cb(er);\n  });\n};\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = normPath(opt.cwd);\n\n  const done = (er, created) => {\n    if (er) cb(er);else {\n      cSet(cache, dir, true);\n      if (created && doChown) chownr(created, uid, gid, er => done(er));else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n  if (dir === cwd) return checkCwd(dir, done);\n  if (preserve) return mkdirp(dir, {\n    mode\n  }).then(made => done(null, made), done);\n  const sub = normPath(path.relative(cwd, dir));\n  const parts = sub.split('/');\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) return cb(null, created);\n  const p = parts.shift();\n  const part = normPath(path.resolve(base + '/' + p));\n  if (cGet(cache, part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path);\n        cb(statEr);\n      } else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) return cb(er);\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n        });\n      } else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n    });\n  } else {\n    created = created || part;\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  }\n};\n\nconst checkCwdSync = dir => {\n  let ok = false;\n  let code = 'ENOTDIR';\n\n  try {\n    ok = fs.statSync(dir).isDirectory();\n  } catch (er) {\n    code = er.code;\n  } finally {\n    if (!ok) throw new CwdError(dir, code);\n  }\n};\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = normPath(opt.cwd);\n\n  const done = created => {\n    cSet(cache, dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n\n  if (dir === cwd) {\n    checkCwdSync(cwd);\n    return done();\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  const sub = normPath(path.relative(cwd, dir));\n  const parts = sub.split('/');\n  let created = null;\n\n  for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    part = normPath(path.resolve(part));\n    if (cGet(cache, part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cSet(cache, part, true);\n    } catch (er) {\n      const st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cSet(cache, part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cSet(cache, part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":{"version":3,"sources":["D:/UIT/Nam3_HKI/OOP/SE100Project/client/node_modules/tar/lib/mkdir.js"],"names":["mkdirp","require","fs","path","chownr","normPath","SymlinkError","Error","constructor","symlink","name","CwdError","code","cGet","cache","key","get","cSet","val","set","checkCwd","dir","cb","stat","er","st","isDirectory","module","exports","opt","umask","mode","needChmod","uid","gid","doChown","processUid","processGid","preserve","unlink","cwd","done","created","chmod","then","made","sub","relative","parts","split","mkdir_","base","length","p","shift","part","resolve","mkdir","onmkdir","lstat","statEr","isSymbolicLink","join","checkCwdSync","ok","statSync","sync","chmodSync","mkdirSync","lstatSync","unlinkSync"],"mappings":"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","sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\nconst normPath = require('./normalize-windows-path.js')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory())\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cSet(cache, dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return checkCwd(dir, done)\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink) {\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok)\n      throw new CwdError(dir, code)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n"]},"metadata":{},"sourceType":"script"}